# a temporary path for storing different credentials
creds_path=$(mktemp -d)

#
# Set up CSCS jfrog registry credentials
# These will be saved as docker credentials in $creds_path/docker
#

if [[ -z "$CSCS_REGISTRY_USERNAME" || -z "$CSCS_REGISTRY_PASSWORD" ]] ; then
    # Obtain credentials for JFrog - required to push the image and meta-data
    creds_json=$(curl --retry 5 --retry-connrefused --fail --silent "$CSCS_CI_MW_URL/credentials?token=$CI_JOB_TOKEN&job_id=$CI_JOB_ID&creds=container_registry")
    oras_creds="$(echo ${creds_json} | jq --join-output '"--username " + .container_registry.username + " --password " +.container_registry.password')"

    jfrog_u="$(echo ${creds_json} | jq -r '.container_registry.username')"
    jfrog_p="$(echo ${creds_json} | jq -r '.container_registry.password')"
    export CSCS_REGISTRY_USERNAME="$jfrog_u"
    export CSCS_REGISTRY_PASSWORD="$jfrog_p"
    log "using credentials provided by cicd-ext"
else
    jfrog_u="$CSCS_REGISTRY_USERNAME"
    jfrog_p="$CSCS_REGISTRY_PASSWORD"
    log "using credentials provided in the environment"
fi

log "log in to jfrog.svc.cscs.ch with oras"

# Create a unique credentials path for this job,
# because by default credentials are stored in ~/.docker/config.json which
# causes conflicts for concurrent jobs.
jfrog_creds_path="${creds_path}/docker/config.json"
log "jfrog credentials to be stored in $jfrog_creds_path"

log "oras login --registry-config ${jfrog_creds_path}  jfrog.svc.cscs.ch --username ${jfrog_u} --password-stdin"
echo ${jfrog_p} | oras login --registry-config ${jfrog_creds_path}  jfrog.svc.cscs.ch --username "${jfrog_u}" --password-stdin
[[ $? -eq 0  ]] || err "failed oras login to JFrog - can't push image to uenv registry"

# Propagate username and password defined in ${pipeline_path}/util/setup-oras (to be used in pre-install script)
BUILD_VARS+=("CSCS_REGISTRY_USERNAME=$jfrog_u" "CSCS_REGISTRY_PASSWORD=$jfrog_p")
BUILD_VAR_NAMES+=("CSCS_REGISTRY_USERNAME" "CSCS_REGISTRY_PASSWORD")

#
# Set up GIT_ASKPASS script if git tokens were provided as pipeline secrets
# The script will be saved as docker credentials in $creds_path/git
#

if env | grep -q '^UENV_CIBUILDV_'; then
    git_creds_path="${creds_path}/git"
    mkdir -p "$git_creds_path"
    askpass_script="$git_creds_path/git-askpass.sh"

    log "GIT_ASKPASS: creating script in $askpass_script"

    # create the header of the askpass script
    ##################
    cat > "$askpass_script" << 'EOF'
#!/bin/sh

prompt="$1"

case "$prompt" in
  *Username*)
    # Git wants a username
    # Use generic token username
    printf '%s' "x-access-token"
    ;;
  *Password*)
    # Git wants a password/token
    # Decide based on host context
    case "$prompt" in

EOF
    ##################

    for var in $(env | grep '^UENV_CIBUILDV_GIT_TOKEN_' | cut -d= -f1); do
        value="$(printenv $var)"
        # skip empty variables
        [ -z "$value" ] && continue

      # Extract host key piece after prefix
      hostkey="${var#UENV_CIBUILDV_GIT_TOKEN_}"
      # Convert underscore to dot to get host
      host="${hostkey//_/.}"

      log "GIT_ASKPASS: storing credentials for $host"

      # append match for host to askpass script
      ##################
      cat >> "$askpass_script" << EOF
    *$host*)
      printf '%s' "$value"
      ;;
EOF
    ##################
      done

    # finish the script
    ##################
    cat >> "$askpass_script" << 'EOF'
    esac
  ;;
esac

# default empty
printf '%s' ""
EOF
    ##################

    chmod +x "$askpass_script"
else
    log "GIT_ASKPASS: No git credentials are configured"
fi
